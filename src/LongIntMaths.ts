// SPDX-FileCopyrightText: Â© 2023 Yake Ho Foong
// SPDX-License-Identifier: MIT

/**
 * This module contains functions that perform arithmetic
 * for 128-bit and 64-bit integers for the random number generators.
 * These are implemented for the sake of speed over the built-in **big int** type.
 * Currently only implemented those needed for the PCG64-DXSM generator.
 * @packageDocumentation
 */

export { int32toNumber, Uint64, Uint128 };

/**
 * System's endianness, needed for speed for the Uint64 class.
 */
const isLittleEnding: boolean = new Uint16Array(new Uint32Array([0xffff0000]).buffer, 0, 1)[0] === 0;
const index0 = isLittleEnding ? 0 : 1;
const index1 = isLittleEnding ? 1 : 0;
const index2 = isLittleEnding ? 2 : 3;
const index3 = isLittleEnding ? 3 : 2;

/**
 * This function is used only in unit tests.
 * It is to deal with the leftmost bit being treated as a special sign bit.
 * @param x - a signed 32-bit integer to be treated as unsigned integer
 * @returns - the parameter x treated as an unsigned integer
 */
// mainly for testing
function int32toNumber(x: number): number {
  if (x >= 0) return x;
  // else, blank out the leftmost bit, convert to type number
  // then add back the leftmost bit
  return Number(x & 0x7fffffff) + 0x80000000;
}

/**
 * A class to do quick calculations on 64-bit unsigned integer maths,
 * including module 2^64. This is implemented for speed, over **bigint** type.
 */
class Uint64 {
  readonly values: Int32Array;
  readonly values16: Uint16Array;

  constructor() {
    this.values = new Int32Array(2);
    this.values16 = new Uint16Array(this.values.buffer);
  }

  /**
   * This method copies the internal state of the given number named in the parameter.
   * @param num - the number whose value (internal state) that we wish to copy.
   * @returns - nothing; object's state/value is updated.
   */
  copyFrom(num: Uint64): void {
    this.values[0] = num.values[0];
    this.values[1] = num.values[1];
  }

  /**
   * This method is mainly used to create a 64-bit unsigned integer
   * using the seeds generated by a SeedSequence object.
   * @see {@link SeedSequence32}
   * @param num1 - the first 32-bits i.e. lower part
   * @param num2 - the second 32-bits i.e. higher part
   * @returns - nothing; object's state/value is updated.
   */
  from32bits(num1: number, num2: number): void {
    this.values[0] = num1 | 0;
    this.values[1] = num2 | 0;
  }

  /**
   * This method is used only in the unit tests.
   * @param x - the bigint value to copy into this object
   * @returns - nothing; object's state/value is updated.
   */
  fromBigint(x: bigint): void {
    this.values[0] = Number(x & 0xffffffffn) | 0;
    this.values[1] = Number((x >> 32n) & 0xffffffffn) | 0;
  }

  /**
   * This method is used only in the unit tests.
   * @returns - a bigint with the value of this object,
   * this object itself is unchanged.
   */
  toBigInt(): bigint {
    return (BigInt(int32toNumber(this.values[1])) << 32n) | BigInt(int32toNumber(this.values[0]));
  }

  private inplace64LeftRotateOrShift(isShift: boolean, numBits: number): void {
    numBits |= 0;

    // break down numbBits into numWords * 32 + numRemBits, where 0 <= numWords < 2 and 0 <= numRemBits < 31
    const numWords: number = numBits >>> 5; // number of 32-bit words
    const numRemBits: number = numBits & 31; // remaining bits after rotating words above; & 31 is the same as % 32

    // assume below that 0 <= numWords < 2, since we assumed that 0 <= numBits < 64
    const newLo: number = numWords > 0 ? (isShift ? 0 : this.values[1]) : this.values[0];
    const newHi: number = numWords > 0 ? this.values[0] : this.values[1];

    if (numRemBits === 0) {
      this.values[0] = newLo;
      this.values[1] = newHi;
    } else {
      const numWrapBits: number = 32 - numRemBits;
      // no need for the & 0xffffffff mask, bitwise operations forces the numbers to be 32-bit
      this.values[0] = newLo << numRemBits;
      if (!isShift) this.values[0] |= newHi >>> numWrapBits;
      // no need for the & 0xffffffff mask, bitwise operations forces the numbers to be 32-bit
      this.values[1] = (newHi << numRemBits) | (newLo >>> numWrapBits);
    }
  }

  /**
   * Left shifts the value of this object by n bits.
   * @numBits - the number of bits to shift left, must be a non-negative integer less than 64
   * @returns - nothing; object's state/value is updated.
   */
  inplace64LeftShift(numBits: number): void {
    this.inplace64LeftRotateOrShift(true, numBits);
  }

  /**
   * Rotates left the value of this object by n bits.
   * @numBits - the number of bits to rotate left, must be a non-negative integer less than 64
   * @returns - nothing; object's state/value is updated.
   */
  inplace64RotateLeft(numBits: number): void {
    this.inplace64LeftRotateOrShift(false, numBits);
  }

  /**
   * Add modulo 2^64.
   * @num2 - the number to be added to this number.
   * @returns - nothing; object's state/value is updated.
   *
   * @remarks
   * Two's complements arithmetic, carry/overflow:
   *
   * if x \> 0 and y \> 0, x + y cannot overflow
   *
   * if x \< 0 and y \< 0, x + y must overflow
   *
   * if x \< 0 and y \> 0, then if (-x) \> y, x + y no overflow, else
   * x + y = 2\^n - (-x) + y = 2\^n + [y - (-x)]
   * =\> no overflow if (-x) \> y, else overflow
   */
  inplace64ModAdd(num2: Uint64): void {
    const lo1: number = this.values[0];
    const lo2: number = num2.values[0];
    this.values[0] = (lo1 + lo2) | 0;
    this.values[1] += lo1 < 0 ? (lo2 < 0 ? 1 : -lo1 > lo2 ? 0 : 1) : lo2 > 0 ? 0 : -lo2 > lo1 ? 0 : 1;
    this.values[1] += num2.values[1];
  }

  /**
   * Xor this number with another number, in place.
   * @num2 - the number to be Xor-ed to this number.
   * @returns - nothing; object's state/value is updated.
   */
  inplaceXorWith(num2: Uint64): void {
    this.values[0] ^= num2.values[0];
    this.values[1] ^= num2.values[1];
  }

  /**
   * @returns - the leftmost 53 bits of this object's value as a number type.
   * Other 11 bits to the right are ignored. Object's value is unchanged.
   */
  leftmost53bits(): number {
    // * 0x200000 is 32 - 11 = 21 bits left shift
    return int32toNumber(this.values[1]) * 0x200000 + (this.values[0] >>> 11);
  }

  /**
   * @returns - ***true*** if the Nth bit from the right is set, else ***false***.
   * N must be less than 64
   */
  isBitNfromRightSet(n: number): boolean {
    if (n <= 32) return ((this.values[0] >>> (n - 1)) & 1) !== 0;
    else return ((this.values[1] >>> (n - 33)) & 1) !== 0;
  }

  /**
   * Takes another number, the parameter, and multiplies onto this object,
   * then applies modulo 2^64 on this object.
   * @param int2 - the number to be multiplied with this object
   * @returns - nothing; object's state/value is updated.
   *
   * @remarks
   * The algorithm below uses traditional long multiplication
   *
   *           a3     a2    	a1      a0
   *           b3     b2       b1      b0
   *                             b0 x a0
   *                     b0 x a1
   *            b0 x a23
   *                     b1 x a0
   *            b1 x a12
   *            b2 x a01
   *            b3 x a0
   */
  inplaceModMult64x64(int2: Uint64): void {
    const num1: Uint16Array = this.values16;
    const num2: Uint16Array = int2.values16;

    const mask: number = 0xffff | 0;

    let val;
    let val1;
    let val2;

    val = Math.imul(num2[index0] | 0, num1[index0] | 0) | 0;
    const result0: number = val & mask;
    val1 = val >>> 16;

    val = Math.imul(num2[index0] | 0, num1[index1] | 0) | 0;
    val1 += val & mask;
    val2 = val >>> 16;
    val = Math.imul(num2[index1] | 0, num1[index0] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    const result1: number = val1 & mask;
    val1 = (val2 + (val1 >>> 16)) | 0;

    // leftmost, due to modulo, just let the product overflow
    // val = (num1[index3] << 16) | num1[index2];
    val = this.values[1];
    val1 += Math.imul(num2[index0] | 0, val | 0) | 0;
    val = (num1[index2] << 16) | num1[index1];
    val1 += Math.imul(num2[index1] | 0, val | 0) | 0;
    // val = (num1[index1] << 16) | num1[index0];
    val = this.values[0];
    val1 += Math.imul(num2[index2] | 0, val | 0) | 0;

    const result2: number = val1 & mask;
    val1 >>>= 16;

    // final one, special
    val1 += Math.imul(num2[index3] | 0, num1[index0] | 0);

    // in place results
    num1[index0] = result0 | 0;
    num1[index1] = result1 | 0;
    num1[index2] = result2 | 0;
    num1[index3] = val1 & mask;
  }

  /**
   * Right shifts the value of this object by 32 bits,
   * then XOR with its original value.
   * @returns - nothing; object's state/value is updated.
   */
  inplace64RightShift32Xor(): void {
    this.values[0] ^= this.values[1];
    // ^=0 is the same as no op
    // this.values[1] ^= 0;
  }

  /**
   * Right shifts the value of this object by 48 bits,
   * then XOR with its original value.
   * @returns - nothing; object's state/value is updated.
   */
  inplace64RightShift48Xor(): void {
    this.values16[index0] ^= this.values16[index3];
    // ^=0 is the same as no op
    // this.values16[index1] ^= 0;
    // this.values16[index2] ^= 0;
    // this.values16[index3] ^= 0;
  }

  /**
   * Right shifts the value of this object by 9 bits.
   * @returns - nothing; object's state/value is updated.
   */
  inplace64RightShift9(): void {
    const num: Int32Array = this.values;

    num[0] >>>= 9;
    num[0] |= (num[1] & 0x1ff) << 23;
    num[1] >>>= 9;
  }

  /**
   * @returns - the rightmost 52 bits of this object's value as a number type.
   * Other 12 bits to the left are ignored. Object's value is unchanged.
   */
  rightmost52bits(): number {
    return int32toNumber(this.values[1] & 0xfffff) * 0x100000000 + int32toNumber(this.values[0]);
  }

  /**
   * @returns - the rightmost 8 bits of this object's value as a number type.
   * Other 56 bits to the left are ignored. Object's value is unchanged.
   */
  rightmostByte(): number {
    return this.values[0] & 0xff;
  }

  /**
   * @returns - ***true*** if the 9th bit from the right is set, else ***false***.
   */
  isBit9fromRightSet(): boolean {
    return (this.values[0] & 0x100) !== 0;
  }

  /**
   * Clears leftmost 12 bits of the value of this object.
   * @returns - nothing; object's state/value is updated.
   */
  clearLeftmost12bits(): void {
    this.values16[index3] &= 0xf;
  }

  /**
   * @param int2 - the number to check against, i.e., is this object less than int2
   * @returns - ***true*** if the value of this object is less than
   * the value of the parameter object, else ***false***.
   */
  isLessThan(int2: Uint64): boolean {
    const num1: Int32Array = this.values;
    const num2: Int32Array = int2.values;

    if (num1[1] > num2[1]) return false;
    if (num1[1] < num2[1]) return true;

    return num1[0] < num2[0];
  }
}

/**
 * A class to do quick calculations on 128-bit unsigned integer maths,
 * and with 64-bit unsigned integers, including module 2^128.
 * This is implemented for speed, over **bigint** type.
 */
class Uint128 {
  /**
   * @internal
   * Do **NOT** use this outside of this module.
   * */
  readonly high64: Uint64;
  /**
   * @internal
   * Do **NOT** use this outside of this module.
   * */
  readonly low64: Uint64;

  constructor() {
    this.high64 = new Uint64();
    this.low64 = new Uint64();
  }

  /**
   * This method is used only in the unit tests.
   * @param x - the bigint value to copy into this object
   * @returns - nothing; object's state/value is updated.
   */
  fromBigint(x: bigint): void {
    this.high64.fromBigint(x >> 64n);
    this.low64.fromBigint(x & 0xffffffffffffffffn);
  }

  /**
   * This method is used only in the unit tests.
   * @returns - a bigint with the value of this object,
   * this object itself is unchanged.
   */
  toBigInt(): bigint {
    return (this.high64.toBigInt() << 64n) | this.low64.toBigInt();
  }

  /**
   * This method is mainly used to create a 128-bit unsigned integer
   * using the seeds generated by a SeedSequence object.
   * @see {@link SeedSequence32}
   * @param num1 - the first 32-bits i.e. lowest part
   * @param num2 - the second 32-bits
   * @param num3 - the third 32-bits
   * @param num4 - the fourth 32-bits i.e. highest part
   * @returns - nothing; object's state/value is updated.
   */
  from32bits(num1: number, num2: number, num3: number, num4: number): void {
    this.low64.from32bits(num1, num2);
    this.high64.from32bits(num3, num4);
  }

  /**
   * Takes another 64-bit integer, the parameter, and multiplies onto this object,
   * then applies modulo 2^128 on this object. Note that the parameter is 64-bits, not 128-bits.
   * @param int64 - the number to be multiplied with this object
   * @returns - nothing; object's state/value is updated.
   *
   * @remarks
   * The algorithm below uses traditional long multiplication
   *
   *   a7     a6   	 a5     a4    	a3     a2    	a1      a0
   *                                   b3     b2       b1      b0
   *                                                     b0 x a0
   *                                            b0 x a1
   *                                    b0 x a2
   *                             0 x a3
   *                      b0 x a4
   *            b0 x a5
   *   b0 x a67
   *                                                b1 x a0
   *                                     b1 x a1
   *                             b1 x a2
   *                      b1 x a3
   *              b1 x a4
   *   b1 x a56
   *                                     b2 x a0
   *                              b2 x a1
   *                       b2 x a2
   *               b2 x a3
   *    b2 x a45
   *                              b3 x a0
   *                        b3 x a1
   *               b3 x a2
   *    b3 x a34
   */
  inplaceModMult128x64(int64: Uint64): void {
    const mask: number = 0xffff | 0;

    let val: number;
    let val1: number;
    let val2: number;

    const num128hi: Uint16Array = this.high64.values16;
    const num128lo: Uint16Array = this.low64.values16;
    const num64: Uint16Array = int64.values16;

    val = Math.imul(num64[index0] | 0, num128lo[index0] | 0) | 0;
    const result0: number = val & mask;
    val1 = val >>> 16;

    val = Math.imul(num64[index0] | 0, num128lo[index1] | 0) | 0;
    val1 += val & mask;
    val2 = val >>> 16;
    val = Math.imul(num64[index1] | 0, num128lo[index0] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    const result1: number = val1 & mask;
    val1 = (val2 + (val1 >>> 16)) | 0;

    val = Math.imul(num64[index0] | 0, num128lo[index2] | 0) | 0;
    val1 += val & mask;
    val2 = val >>> 16;
    val = Math.imul(num64[index1] | 0, num128lo[index1] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    val = Math.imul(num64[index2] | 0, num128lo[index0] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    const result2: number = val1 & mask;
    val1 = (val2 + (val1 >>> 16)) | 0;

    val = Math.imul(num64[index0] | 0, num128lo[index3] | 0) | 0;
    val1 += val & mask;
    val2 = val >>> 16;
    val = Math.imul(num64[index1] | 0, num128lo[index2] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    val = Math.imul(num64[index2] | 0, num128lo[index1] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    val = Math.imul(num64[index3] | 0, num128lo[index0] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    const result3: number = val1 & mask;
    val1 = (val2 + (val1 >>> 16)) | 0;

    val = Math.imul(num64[index0] | 0, num128hi[index0] | 0) | 0;
    val1 += val & mask;
    val2 = val >>> 16;
    val = Math.imul(num64[index1] | 0, num128lo[index3] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    val = Math.imul(num64[index2] | 0, num128lo[index2] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    val = Math.imul(num64[index3] | 0, num128lo[index1] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    const result4: number = val1 & mask;
    val1 = (val2 + (val1 >>> 16)) | 0;

    val = Math.imul(num64[index0] | 0, num128hi[index1] | 0) | 0;
    val1 += val & mask;
    val2 = val >>> 16;
    val = Math.imul(num64[index1] | 0, num128hi[index0] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    val = Math.imul(num64[index2] | 0, num128lo[index3] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    val = Math.imul(num64[index3] | 0, num128lo[index2] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    const result5: number = val1 & mask;
    val1 = (val2 + (val1 >>> 16)) | 0;

    // leftmost, due to modulo, just let the product overflow
    val = this.high64.values[1]; // (num128hi[index3] << 16) | num128hi[index2];
    val1 += Math.imul(num64[0] | 0, val | 0) | 0;
    val = (num128hi[index2] << 16) | num128hi[index1];
    val1 += Math.imul(num64[1] | 0, val | 0) | 0;
    val = this.high64.values[0]; // (num128hi[index1] << 16) | num128hi[index0];
    val1 += Math.imul(num64[2] | 0, val | 0) | 0;
    val = (num128hi[index0] << 16) | num128lo[index3];
    val1 += Math.imul(num64[3] | 0, val | 0) | 0;

    // fill in the in place results
    num128lo[index0] = result0 | 0;
    num128lo[index1] = result1 | 0;
    num128lo[index2] = result2 | 0;
    num128lo[index3] = result3 | 0;
    num128hi[index0] = result4 | 0;
    num128hi[index1] = result5 | 0;
    num128hi[index2] = val1 & mask;
    num128hi[index3] = val1 >>> 16;
  }

  /**
   * Takes another 128-bit integer, the parameter, and multiplies onto this object,
   * then applies modulo 2^128 on this object.
   * @param int128 - the number to be multiplied with this object
   * @returns - nothing; object's state/value is updated.
   *
   * @remarks
   *
   * The algorithm below uses traditional long multiplication
   *
   *   a7     a6   	 a5     a4    	a3     a2    	a1      a0
   *   b7     b6       b5     b4      b3     b2       b1      b0
   *                                                     b0 x a0
   *                                            b0 x a1
   *                                    b0 x a2
   *                               b0 x a3
   *                      b0 x a4
   *            b0 x a5
   *   b0 x a67
   *                                                b1 x a0
   *                                     b1 x a1
   *                             b1 x a2
   *                      b1 x a3
   *              b1 x a4
   *   b1 x a56
   *                                     b2 x a0
   *                              b2 x a1
   *                       b2 x a2
   *               b2 x a3
   *    b2 x a45
   *                              b3 x a0
   *                        b3 x a1
   *               b3 x a2
   *    b3 x a34
   *                        b4 x a0
   *               b4 x a1
   *    b4 x a32
   *               b5 x a0
   *    b5 x a12
   *    b6 x a01
   *b7 x a0
   */
  inplaceModMult128x128(int128: Uint128): void {
    const mask: number = 0xffff | 0;
    let val: number;
    let val1: number;
    let val2: number;

    const num1hi: Uint16Array = this.high64.values16;
    const num1lo: Uint16Array = this.low64.values16;
    const num2lo: Uint16Array = int128.low64.values16;
    const num2hi: Uint16Array = int128.high64.values16;

    val = Math.imul(num2lo[index0] | 0, num1lo[index0] | 0) | 0;
    const result0: number = val & mask;
    val1 = val >>> 16;

    val = Math.imul(num2lo[index0] | 0, num1lo[index1] | 0) | 0;
    val1 += val & mask;
    val2 = val >>> 16;
    val = Math.imul(num2lo[index1] | 0, num1lo[index0] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    const result1: number = val1 & mask;
    val1 = (val2 + (val1 >>> 16)) | 0;

    val = Math.imul(num2lo[index0] | 0, num1lo[index2] | 0) | 0;
    val1 += val & mask;
    val2 = val >>> 16;
    val = Math.imul(num2lo[index1] | 0, num1lo[index1] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    val = Math.imul(num2lo[index2] | 0, num1lo[index0] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    const result2: number = val1 & mask;
    val1 = (val2 + (val1 >>> 16)) | 0;

    val = Math.imul(num2lo[index0] | 0, num1lo[index3] | 0) | 0;
    val1 += val & mask;
    val2 = val >>> 16;
    val = Math.imul(num2lo[index1] | 0, num1lo[index2] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    val = Math.imul(num2lo[index2] | 0, num1lo[index1] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    val = Math.imul(num2lo[index3] | 0, num1lo[index0] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    const result3: number = val1 & mask;
    val1 = (val2 + (val1 >>> 16)) | 0;

    val = Math.imul(num2lo[index0] | 0, num1hi[index0] | 0) | 0;
    val1 += val & mask;
    val2 = val >>> 16;
    val = Math.imul(num2lo[index1] | 0, num1lo[index3] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    val = Math.imul(num2lo[index2] | 0, num1lo[index2] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    val = Math.imul(num2lo[index3] | 0, num1lo[index1] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    val = Math.imul(num2hi[index0] | 0, num1lo[index0] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    const result4: number = val1 & mask;
    val1 = (val2 + (val1 >>> 16)) | 0;

    val = Math.imul(num2lo[index0] | 0, num1hi[index1] | 0) | 0;
    val1 += val & mask;
    val2 = val >>> 16;
    val = Math.imul(num2lo[index1] | 0, num1hi[index0] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    val = Math.imul(num2lo[index2] | 0, num1lo[index3] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    val = Math.imul(num2lo[index3] | 0, num1lo[index2] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    val = Math.imul(num2hi[index0] | 0, num1lo[index1] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    val = Math.imul(num2hi[index1] | 0, num1lo[index0] | 0) | 0;
    val1 += val & mask;
    val2 += val >>> 16;
    const result5: number = val1 & mask;
    val1 = (val2 + (val1 >>> 16)) | 0;

    // leftmost, due to modulo, just let the product overflow
    val = this.high64.values[1]; // (num1hi[index3] << 16) | num1hi[index2];
    val1 += Math.imul(num2lo[index0] | 0, val | 0) | 0;
    val = (num1hi[index2] << 16) | num1hi[index1];
    val1 += Math.imul(num2lo[index1] | 0, val | 0) | 0;
    val = this.high64.values[0]; // (num1hi[index1] << 16) | num1hi[index0];
    val1 += Math.imul(num2lo[index2] | 0, val | 0) | 0;
    val = (num1hi[index0] << 16) | num1lo[index3];
    val1 += Math.imul(num2lo[index3] | 0, val | 0) | 0;
    // part 2
    val = this.low64.values[1]; // (num1lo[index3] << 16) | num1lo[index2];
    val1 += Math.imul(num2hi[index0] | 0, val | 0) | 0;
    val = (num1lo[index2] << 16) | num1lo[index1];
    val1 += Math.imul(num2hi[index1] | 0, val | 0) | 0;
    val = this.low64.values[0]; // (num1lo[index1] << 16) | num1lo[index0];
    val1 += Math.imul(num2hi[index2] | 0, val | 0) | 0;
    // save result
    const result6: number = val1 & mask;
    val1 >>>= 16;

    // final one, special
    val1 += Math.imul(num2hi[index3] | 0, num1lo[index0] | 0);

    // fill in the in place results
    num1lo[index0] = result0 | 0;
    num1lo[index1] = result1 | 0;
    num1lo[index2] = result2 | 0;
    num1lo[index3] = result3 | 0;
    num1hi[index0] = result4 | 0;
    num1hi[index1] = result5 | 0;
    num1hi[index2] = result6 | 0;
    num1hi[index3] = val1 & mask;
  }

  /**
   * Takes another 128-bit integer, the parameter, and adds it onto this object,
   * then applies modulo 2^128 on this object.
   * @param int2 - the number to be added to this object
   * @returns - nothing; object's state/value is updated.
   */
  inplaceModAdd128(int2: Uint128): void {
    const num1lo: Uint16Array = this.low64.values16;
    const num1hi: Uint16Array = this.high64.values16;
    const num2lo: Uint16Array = int2.low64.values16;
    const num2hi: Uint16Array = int2.high64.values16;

    const mask: number = 0xffff | 0;

    let val: number = num1lo[index0] + num2lo[index0];
    num1lo[index0] = val & mask;

    val >>>= 16;
    val += num1lo[index1] + num2lo[index1];
    num1lo[index1] = val & mask;

    val >>>= 16;
    val += num1lo[index2] + num2lo[index2];
    num1lo[index2] = val & mask;

    val >>>= 16;
    val += num1lo[index3] + num2lo[index3];
    num1lo[index3] = val & mask;

    val >>>= 16;
    val += num1hi[index0] + num2hi[index0];
    num1hi[index0] = val & mask;

    val >>>= 16;
    val += num1hi[index1] + num2hi[index1];
    num1hi[index1] = val & mask;

    val >>>= 16;
    val += num1hi[index2] + num2hi[index2];
    num1hi[index2] = val & mask;

    val >>>= 16;
    val += num1hi[index3] + num2hi[index3];
    num1hi[index3] = val & mask;
  }

  /**
   * Left shifts the value of this object by 1 bit,
   * then sets the rightmost bit to 1.
   * @returns - nothing; object's state/value is updated.
   */
  inplaceMod128LeftShift1or1(): void {
    const numLo: Int32Array = this.low64.values;
    const numHi: Int32Array = this.high64.values;

    const carryLo0: number = numLo[0] < 0 ? 1 | 0 : 0 | 0;
    const carryLo1: number = numLo[1] < 0 ? 1 | 0 : 0 | 0;
    const carryHi0: number = numHi[0] < 0 ? 1 | 0 : 0 | 0;

    numLo[0] = (numLo[0] << 1) | 1;
    numLo[1] = (numLo[1] << 1) | carryLo0;
    numHi[0] = (numHi[0] << 1) | carryLo1;
    numHi[1] = (numHi[1] << 1) | carryHi0;
  }
}
